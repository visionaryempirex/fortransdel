
"use client";
import { useState, useEffect } from "react";
import "./CreateInterview.css";
import { Link } from "react-router-dom";
import Step1 from "./InterviewCreating-steps/Step1/Step1";
import Step2 from "./InterviewCreating-steps/Step2/Step2";
import { useNavigate } from "react-router-dom";
import Swal from "sweetalert2";
import { postReq, putReq } from "../../../../api/request";

const CreateInterview = () => {
  const navigate = useNavigate();
  const [users, setUsers] = useState([]);
  const [limit, setLimit] = useState(3);
  const [allInterviewsData, setAllInterviewsData] = useState([]);

  const loginedEmail = JSON.parse(localStorage.getItem("LoginedEmail"));

  // Step 1 Settings
  const [candidateThinkingTime, setCandidateThinkingTime] = useState("1 minute");
  const [candidateMaxAnswerLength, setCandidateMaxAnswerLength] = useState("2 minutes");
  const [brandingColorOrLogo, setBrandingColorOrLogo] = useState("No");
  const [answerRetakesAllowed, setAnswerRetakesAllowed] = useState("Allowed");

  // Step 2 Data
  const [interviewStartVideo, setInterviewStartVideo] = useState(null);
  const [interviewStartTitle, setInterviewStartTitle] = useState("");
  const [interviewStartTag, setInterviewStartTag] = useState("");
  const [questions, setQuestions] = useState([]);
  const [farewell, setFarewell] = useState([]);

  const [step, setStep] = useState(1);
  const [isUploading, setIsUploading] = useState(false);

  useEffect(() => {
    let userIntervalId;

    const fetchUsers = async () => {
      try {
        const data = await postReq("/users/GetUserByEmail", { companyEmail: loginedEmail });
        if (data && data.User) {
          setUsers(data.User);
        } else {
          console.error("No data returned from the server.");
        }
      } catch (error) {
        console.error("Error fetching users:", error);
      }
    };

    fetchUsers();
    userIntervalId = setInterval(fetchUsers, 5000);

    return () => clearInterval(userIntervalId);
  }, [loginedEmail]);

  useEffect(() => {
    let interviewIntervalId;

    const fetchInterviews = async () => {
      try {
        const result = await postReq("/interview/GetInterviewsbyEmail", { email: loginedEmail });
        if (result) {
          console.log("interviews", result);
          setAllInterviewsData(result.interviews);
        } else {
          console.error(result?.message || "Error fetching interviews.");
        }
      } catch (error) {
        console.error("Error fetching interviews:", error);
      }
    };

    fetchInterviews();
    interviewIntervalId = setInterval(fetchInterviews, 5000);

    return () => clearInterval(interviewIntervalId);
  }, [loginedEmail]);

  useEffect(() => {
    let interviewCount = 0;

    allInterviewsData.forEach((data) => {
      if (loginedEmail === data.email) {
        interviewCount += 1;
      }
    });

    if (loginedEmail === users.companyEmail) {
      if (users.Limit) {
        setLimit(users.Limit);
      } else {
        setLimit(3);
      }
    }

    if (interviewCount >= limit) {
      navigate("/All-Interviews");
    }
  }, [allInterviewsData, users, loginedEmail, limit, navigate]);

  const moveToStepForward = () => {
    if (candidateThinkingTime && candidateMaxAnswerLength && brandingColorOrLogo && answerRetakesAllowed) {
      setStep(step + 1);
    } else {
      Swal.fire({
        icon: "warning",
        title: "Please fill all the fields",
        toast: true,
        position: "top-end",
        showConfirmButton: false,
        timer: 3000,
        timerProgressBar: true,
      });
    }
  };

  const moveToStepPrevious = () => {
    if (step === 1) {
      navigate("/All-Interviews");
    } else {
      setStep(step - 1);
    }
  };

  const uploadToCloudinary = async (file) => {
    const formData = new FormData();
    formData.append("file", file);
    formData.append("upload_preset", "InterviewVideo");

    try {
      const response = await fetch(`https://api.cloudinary.com/v1_1/dxl1ejhcc/video/upload`, {
        method: "POST",
        body: formData,
      });

      const responseData = await response.json();

      if (!response.ok) {
        console.error("Cloudinary Upload Failed:", responseData);
        throw new Error(responseData.error?.message || "Unknown error occurred");
      }

      return responseData.secure_url;
    } catch (error) {
      console.error("Upload error:", error);
      throw error;
    }
  };

  const saveInterview = async () => {
    // Validation
    if (
      !candidateThinkingTime ||
      !candidateMaxAnswerLength ||
      !brandingColorOrLogo ||
      !answerRetakesAllowed ||
      !interviewStartVideo ||
      !interviewStartTitle ||
      questions.length === 0 ||
      farewell.length === 0
    ) {
      let errorMessage = "Please fill all required fields: ";
      const missingFields = [];
      
      if (!candidateThinkingTime) missingFields.push("Thinking Time");
      if (!candidateMaxAnswerLength) missingFields.push("Answer Length");
      if (!brandingColorOrLogo) missingFields.push("Branding");
      if (!answerRetakesAllowed) missingFields.push("Retakes");
      if (!interviewStartVideo) missingFields.push("Interview Start Video");
      if (!interviewStartTitle) missingFields.push("Interview Start Title");
      if (questions.length === 0) missingFields.push("Questions");
      if (farewell.length === 0) missingFields.push("Farewell");

      errorMessage += missingFields.join(", ");
      
      Swal.fire({
        icon: "error",
        title: "Missing Required Fields",
        text: errorMessage,
      });
      return;
    }

    // Check if all questions have required fields
    const incompleteQuestions = questions.filter(q => !q.title || !q.description || !q.video);
    if (incompleteQuestions.length > 0) {
      Swal.fire({
        icon: "error",
        title: "Incomplete Questions",
        text: "Please ensure all questions have a title, description, and video.",
      });
      return;
    }

    // Check farewell completion
    if (!farewell[0]?.title || !farewell[0]?.description || !farewell[0]?.video) {
      Swal.fire({
        icon: "error",
        title: "Incomplete Farewell",
        text: "Please ensure the farewell has a title, description, and video.",
      });
      return;
    }

    setIsUploading(true);

    try {
      // Upload intro video to Cloudinary
      let introVideoUrl = interviewStartVideo;
      if (interviewStartVideo && typeof interviewStartVideo === 'object') {
        introVideoUrl = await uploadToCloudinary(interviewStartVideo);
      }

      // Upload question videos to Cloudinary
      const updatedQuestions = await Promise.all(
        questions.map(async (question) => {
          let videoUrl = question.video;
          if (question.video && typeof question.video === 'object') {
            videoUrl = await uploadToCloudinary(question.video);
          }
          return {
            ...question,
            video: videoUrl,
            Timetothink: question.Timetothink || candidateThinkingTime,
            Timetoanswer: question.Timetoanswer || candidateMaxAnswerLength,
            Retakes: question.Retakes || answerRetakesAllowed,
          };
        })
      );

      // Upload farewell video to Cloudinary
      let farewellVideoUrl = farewell[0].video;
      if (farewell[0].video && typeof farewell[0].video === 'object') {
        farewellVideoUrl = await uploadToCloudinary(farewell[0].video);
      }

      const updatedFarewell = [{
        ...farewell[0],
        video: farewellVideoUrl,
      }];

      // Prepare data for API
      const interviewData = {
        interviewTitle: interviewStartTitle,
        candidateThinkingTime: candidateThinkingTime,
        candidateMaxAnswerLength: candidateMaxAnswerLength,
        brandingColorOrLogo: brandingColorOrLogo,
        answerRetakesAllowed: answerRetakesAllowed,
        interviewStart: {
          video: introVideoUrl,
          title: interviewStartTitle,
          tag: interviewStartTag || "interview",
        },
        questions: updatedQuestions,
        farewell: updatedFarewell[0],
        email: loginedEmail,
        Status: "Open",
      };

      const userUpdatedObj = {
        _id: users._id,
        Limit: users.Limit,
        Plan: users.Plan,
        Status: users.Status,
        companyEmail: users.companyEmail,
        companyEmailPassword: users.companyEmailPassword,
        companyLocation: users.companyLocation,
        companyName: users.companyName,
        userId: users.userId,
        userName: users.userName,
        CreatedInterviews: (users.CreatedInterviews || 0) + 1,
      };

      // Save to database
      const interviewAddApi = await postReq("/interview/CreateInterview", interviewData);
      const userUpdateApi = await putReq("/users/UpdateUser", userUpdatedObj);

      if (interviewAddApi && userUpdateApi) {
        Swal.fire({
          icon: "success",
          title: "Interview Created Successfully",
          toast: true,
          position: "top-end",
          showConfirmButton: false,
          timer: 3000,
          timerProgressBar: true,
        });
        
        // Clear local storage
        localStorage.removeItem("interviewData");
        
        setTimeout(() => {
          navigate("/All-Interviews");
        }, 3000);
      } else {
        throw new Error("Failed to save interview to database");
      }
    } catch (error) {
      console.error("Error saving interview:", error);
      Swal.fire({
        icon: "error",
        title: "Save Error",
        text: error.message || "An error occurred while saving the interview. Please try again.",
      });
    } finally {
      setIsUploading(false);
    }
  };

  return (
    <div className="enhanced-interview-creator">
      <div className="flex">
        <Link to="/All-Interviews"></Link>
        {step === 1 && (
          <Step1
            nextStep={moveToStepForward}
            prevStep={moveToStepPrevious}
            candidateThinkingTime={setCandidateThinkingTime}
            candidateMaxAnswerLength={setCandidateMaxAnswerLength}
            brandingColorOrLogo={setBrandingColorOrLogo}
            answerRetakesAllowed={setAnswerRetakesAllowed}
            candidateThinkingTimeValue={candidateThinkingTime}
            candidateMaxAnswerLengthValue={candidateMaxAnswerLength}
            brandingColorOrLogoValue={brandingColorOrLogo}
            answerRetakesAllowedValue={answerRetakesAllowed}
          />
        )}
        {step === 2 && (
          <Step2
            prevStep={moveToStepPrevious}
            interviewStartTitle={interviewStartTitle}
            setInterviewStartTitle={setInterviewStartTitle}
            interviewStartVideo={interviewStartVideo}
            setInterviewStartVideo={setInterviewStartVideo}
            interviewStartTag={interviewStartTag}
            setInterviewStartTag={setInterviewStartTag}
            questions={questions}
            setQuestions={setQuestions}
            farewell={farewell}
            setFarewell={setFarewell}
            saveInterview={saveInterview}
            isUploading={isUploading}
            candidateThinkingTime={candidateThinkingTime}
            candidateMaxAnswerLength={candidateMaxAnswerLength}
            answerRetakesAllowed={answerRetakesAllowed}
          />
        )}
      </div>
    </div>
  );
};

export default CreateInterview;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

"use client";
import "./Step1.css";

const Step1 = (props) => {
  const handleThinkingTimeChange = (e) => {
    props.candidateThinkingTime(e.target.value);
  };

  const handleMaxAnswerLengthChange = (e) => {
    props.candidateMaxAnswerLength(e.target.value);
  };

  const handleBrandingChange = (e) => {
    props.brandingColorOrLogo(e.target.value);
  };

  const handleRetakesChange = (e) => {
    props.answerRetakesAllowed(e.target.value);
  };

  return (
    <div className="listandcreateinterviewsstep1-flex">
      <div style={{ paddingLeft: "25px" }}>
        <button
          onClick={props.prevStep}
          className="listandcreateinterviewsstep1-video-interview-create-button"
          style={{ marginBottom: "20px" }}
        >
          Back
        </button>
      </div>
      <div
        style={{
          width: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
        }}
      >
        <div
          className="listandcreateinterviewsstep1-video-interview-container"
          style={{ maxWidth: "96.3%" }}
        >
          <div className="listandcreateinterviewsstep1-video-interview-section">
            <div className="listandcreateinterviewsstep1-video-interview-left">
              <div className="listandcreateinterviewsstep1-video-interview-placeholder-image">
                <div className="listandcreateinterviewsstep1-video-icon">
                  <svg
                    width="48"
                    height="48"
                    viewBox="0 0 24 24"
                    fill="none"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <path d="M14.7295 2H9.26953V6H14.7295V2Z" fill="currentColor" />
                    <path d="M16.7295 8V6H14.7295V8H16.7295Z" fill="currentColor" />
                    <path d="M16.7295 8H18.7295V16H16.7295V8Z" fill="currentColor" />
                    <path d="M14.7295 18V16H9.26953V18H14.7295Z" fill="currentColor" />
                    <path d="M7.26953 16V8H9.26953V6H7.26953V8H5.26953V16H7.26953Z" fill="currentColor" />
                    <path d="M12 10L15 12.5L12 15V10Z" fill="white" />
                  </svg>
                </div>
                {/* <div className="listandcreateinterviewsstep1-upload-text">
                  <span>Upload Video</span>
                  <small>or record new</small>
                </div> */}
              </div>
              <div className="listandcreateinterviewsstep1-content-wrapper">
                <h2 className="listandcreateinterviewsstep1-main-title">Video Interview Setup</h2>
                <p className="listandcreateinterviewsstep1-main-description">
                Set up your interview and create a great candidate experience.
                </p>
                <button
                  className="listandcreateinterviewsstep1-video-interview-create-button"
                  onClick={props.nextStep}
                >
                  <svg
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <path
                      d="M12 5V19M5 12H19"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                    />
                  </svg>
                  Create Interview
                </button>
              </div>
            </div>

            <div className="listandcreateinterviewsstep1-video-interview-right">
              <div className="listandcreateinterviewsstep1-settings-header">
                <h3>Interview Settings</h3>
              </div>

              <div className="listandcreateinterviewsstep1-video-interview-setting-item">
                <div className="listandcreateinterviewsstep1-setting-info">
                  <span>Thinking Time</span>
                  <small>Time to prepare answer</small>
                </div>
                <select
                  className="listandcreateinterviewsstep1-setting-select"
                  onChange={handleThinkingTimeChange}
                  value={props.candidateThinkingTimeValue}
                >
                  <option value="" disabled>
                    Thinking Time
                  </option>
                  <option value="30 seconds">30 seconds</option>
                  <option value="1 minute">1 minute</option>
                  <option value="2 minutes">2 minutes</option>
                  <option value="3 minutes">3 minutes</option>
                  <option value="4 minutes">4 minutes</option>
                  <option value="5 minutes">5 minutes</option>
                </select>
              </div>

              <div className="listandcreateinterviewsstep1-video-interview-setting-item">
                <div className="listandcreateinterviewsstep1-setting-info">
                  <span>Answer Length</span>
                  <small>Max recording time</small>
                </div>
                <select
                  className="listandcreateinterviewsstep1-setting-select"
                  onChange={handleMaxAnswerLengthChange}
                  value={props.candidateMaxAnswerLengthValue}
                >
                  <option value="" disabled>
                    Answer Length
                  </option>
                  <option value="1 minute">1 minute</option>
                  <option value="2 minutes">2 minutes</option>
                  <option value="3 minutes">3 minutes</option>
                  <option value="4 minutes">4 minutes</option>
                  <option value="5 minutes">5 minutes</option>
                </select>
              </div>

              <div className="listandcreateinterviewsstep1-video-interview-setting-item">
                <div className="listandcreateinterviewsstep1-setting-info">
                  <span>Branding</span>
                  <small>Custom appearance</small>
                </div>
                <select
                  className="listandcreateinterviewsstep1-setting-select"
                  onChange={handleBrandingChange}
                  value={props.brandingColorOrLogoValue}
                >
                  <option value="" disabled>
                    Branding
                  </option>
                  <option value="No">No</option>
                  <option value="Logo">Logo</option>
                  <option value="Color">Color</option>
                </select>
              </div>

              <div className="listandcreateinterviewsstep1-video-interview-setting-item">
                <div className="listandcreateinterviewsstep1-setting-info">
                  <span>Retakes</span>
                  <small>Allow re-recording</small>
                </div>
                <select
                  className="listandcreateinterviewsstep1-setting-select"
                  onChange={handleRetakesChange}
                  value={props.answerRetakesAllowedValue}
                >
                  <option value="" disabled>
                    Retakes
                  </option>
                  <option value="None">None</option>
                  <option value="Allowed">Allowed</option>
                  <option value="Not Allowed">Not Allowed</option>
                </select>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Step1;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



"use client"
import { useState, useEffect } from "react"
import { FiSettings, FiTrash, FiX } from "react-icons/fi"
import { GiPartyPopper } from "react-icons/gi"
import { FaVideo, FaSpinner } from "react-icons/fa"
import Swal from "sweetalert2"
import withReactContent from "sweetalert2-react-content"
import "./Step2.css"
import { MdDragIndicator } from "react-icons/md"

const MySwal = withReactContent(Swal)

const Step2 = (props) => {
  const [showSettingsPopup, setShowSettingsPopup] = useState(false)
  const [currentQuestionSettings, setCurrentQuestionSettings] = useState(null)
  const [questionSettings, setQuestionSettings] = useState({})
  const [isPopupOpen, setIsPopupOpen] = useState(false)
  const [previewCount, setPreviewCount] = useState(0)
  const [draggedItem, setDraggedItem] = useState(null)

  // Auto-save functionality
  useEffect(() => {
    const interviewData = {
      interviewStartVideo: props.interviewStartVideo,
      interviewStartTitle: props.interviewStartTitle,
      interviewStartTag: props.interviewStartTag,
      questions: props.questions,
      farewell: props.farewell,
    }
    localStorage.setItem("interviewData", JSON.stringify(interviewData))
  }, [props.interviewStartVideo, props.interviewStartTitle, props.interviewStartTag, props.questions, props.farewell])

  // Load saved data on component mount
  useEffect(() => {
    const savedData = localStorage.getItem("interviewData")
    if (savedData) {
      const parsedData = JSON.parse(savedData)
      if (parsedData.interviewStartTitle) props.setInterviewStartTitle(parsedData.interviewStartTitle)
      if (parsedData.interviewStartTag) props.setInterviewStartTag(parsedData.interviewStartTag)
      if (parsedData.questions) props.setQuestions(parsedData.questions)
      if (parsedData.farewell) props.setFarewell(parsedData.farewell)
    }
  }, [])

  const settingsOptions = {
    Timetothink: [
      { value: "30 seconds", label: "30 seconds" },
      { value: "1 minute", label: "1 minute" },
      { value: "2 minutes", label: "2 minutes" },
      { value: "3 minutes", label: "3 minutes" },
      { value: "4 minutes", label: "4 minutes" },
      { value: "5 minutes", label: "5 minutes" },
    ],
    Timetoanswer: [
      { value: "30 seconds", label: "30 seconds" },
      { value: "1 minute", label: "1 minute" },
      { value: "2 minutes", label: "2 minutes" },
      { value: "3 minutes", label: "3 minutes" },
      { value: "4 minutes", label: "4 minutes" },
      { value: "5 minutes", label: "5 minutes" },
    ],
    Retakes: [
      { value: "None", label: "None" },
      { value: "1 Retake", label: "1 Retake" },
      { value: "2 Retakes", label: "2 Retakes" },
      { value: "3 Retakes", label: "3 Retakes" },
      { value: "Unlimited", label: "Unlimited" },
    ],
  }

  // File handling functions
  const handleFileSelect = (callback, multiple = false) => {
    const input = document.createElement("input")
    input.type = "file"
    input.accept = "video/*"
    input.multiple = multiple

    input.onchange = (e) => {
      const files = e.target.files
      if (files && files.length > 0) {
        callback(files[0])
      }
    }

    input.click()
  }

  const handleDragOver = (e) => {
    e.preventDefault()
    e.stopPropagation()
    e.currentTarget.classList.add("drag-over")
  }

  const handleDragLeave = (e) => {
    e.preventDefault()
    e.stopPropagation()
    e.currentTarget.classList.remove("drag-over")
  }

  const handleDrop = (e, callback) => {
    e.preventDefault()
    e.stopPropagation()
    e.currentTarget.classList.remove("drag-over")

    const files = e.dataTransfer.files
    if (files && files.length > 0) {
      const file = files[0]
      if (file.type.startsWith("video/")) {
        callback(file)
      } else {
        Swal.fire({
          icon: "error",
          title: "Invalid File Type",
          text: "Please upload a video file.",
        })
      }
    }
  }

  // Camera recording function
  const recordVideo = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true })
      const mediaRecorder = new MediaRecorder(stream)
      const chunks = []

      mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) {
          chunks.push(e.data)
        }
      }

      const video = document.createElement("video")
      video.srcObject = stream
      video.autoplay = true
      video.muted = true
      video.style.width = "100%"
      video.style.maxHeight = "300px"

      return new Promise((resolve, reject) => {
        MySwal.fire({
          title: "Recording Video",
          html: '<div id="video-container"></div>',
          showCancelButton: true,
          confirmButtonText: "Start Recording",
          cancelButtonText: "Cancel",
          didOpen: () => {
            const container = document.getElementById("video-container")
            if (container) {
              container.appendChild(video)
            }
          },
          preConfirm: () => {
            mediaRecorder.start()
            return new Promise((innerResolve) => {
              MySwal.fire({
                title: "Recording in Progress...",
                html: '<div id="recording-container"></div>',
                showCancelButton: false,
                confirmButtonText: "Stop Recording",
                allowOutsideClick: false,
                didOpen: () => {
                  const container = document.getElementById("recording-container")
                  if (container) {
                    const recordingVideo = video.cloneNode()
                    recordingVideo.srcObject = stream
                    recordingVideo.autoplay = true
                    recordingVideo.muted = true
                    container.appendChild(recordingVideo)
                  }
                },
                preConfirm: () => {
                  return new Promise((stopResolve) => {
                    mediaRecorder.onstop = () => {
                      const blob = new Blob(chunks, { type: "video/webm" })
                      const file = new File([blob], "recorded-video.webm", { type: "video/webm" })
                      stream.getTracks().forEach((track) => track.stop())
                      stopResolve(file)
                    }
                    mediaRecorder.stop()
                  })
                },
              }).then((result) => {
                if (result.isConfirmed) {
                  innerResolve(result.value)
                }
              })
            })
          },
        }).then((result) => {
          if (result.isConfirmed) {
            resolve(result.value)
          } else {
            stream.getTracks().forEach((track) => track.stop())
            reject(new Error("Recording cancelled"))
          }
        })
      })
    } catch (error) {
      console.error("Camera access error:", error)
      throw new Error("Camera access denied or not available")
    }
  }

  // Video upload handlers
  const handleIntroVideoUpload = async (method = "upload") => {
    try {
      let file

      if (method === "record") {
        file = await recordVideo()
      } else if (method === "upload") {
        file = await new Promise((resolve) => {
          handleFileSelect(resolve)
        })
      }

      if (file) {
        props.setInterviewStartVideo(file)
      }
    } catch (error) {
      console.error("Error handling intro video:", error)
      if (error.message !== "Recording cancelled") {
        Swal.fire({
          icon: "error",
          title: "Upload Error",
          text: error.message || "Failed to process video",
        })
      }
    }
  }

  const handleQuestionVideoUpload = async (questionId, method = "upload") => {
    const question = props.questions.find((q) => q.id === questionId)
    if (!question.title || !question.description) {
      Swal.fire({
        icon: "warning",
        title: "Missing Information",
        text: "Please enter question title and description first.",
      })
      return
    }

    try {
      let file

      if (method === "record") {
        file = await recordVideo()
      } else if (method === "upload") {
        file = await new Promise((resolve) => {
          handleFileSelect(resolve)
        })
      }

      if (file) {
        const updatedQuestions = props.questions.map((q) => (q.id === questionId ? { ...q, video: file } : q))
        props.setQuestions(updatedQuestions)
      }
    } catch (error) {
      console.error("Error handling question video:", error)
      if (error.message !== "Recording cancelled") {
        Swal.fire({
          icon: "error",
          title: "Upload Error",
          text: error.message || "Failed to process video",
        })
      }
    }
  }

  const handleFarewellVideoUpload = async (farewellId, method = "upload") => {
    const farewellItem = props.farewell.find((f) => f.id === farewellId)
    if (!farewellItem.title || !farewellItem.description) {
      Swal.fire({
        icon: "warning",
        title: "Missing Information",
        text: "Please enter farewell title and description first.",
      })
      return
    }

    try {
      let file

      if (method === "record") {
        file = await recordVideo()
      } else if (method === "upload") {
        file = await new Promise((resolve) => {
          handleFileSelect(resolve)
        })
      }

      if (file) {
        const updatedFarewell = props.farewell.map((f) => (f.id === farewellId ? { ...f, video: file } : f))
        props.setFarewell(updatedFarewell)
      }
    } catch (error) {
      console.error("Error handling farewell video:", error)
      if (error.message !== "Recording cancelled") {
        Swal.fire({
          icon: "error",
          title: "Upload Error",
          text: error.message || "Failed to process video",
        })
      }
    }
  }

  // Question management
  const handleAddQuestion = () => {
    const newQuestion = {
      id: props.questions.length + 1,
      title: "",
      description: "",
      video: null,
      Timetothink: props.candidateThinkingTime,
      Timetoanswer: props.candidateMaxAnswerLength,
      Retakes: props.answerRetakesAllowed,
    }
    props.setQuestions([...props.questions, newQuestion])
  }

  const handleRemoveQuestion = (id) => {
    const updatedQuestions = props.questions.filter((q) => q.id !== id)
    const renumberedQuestions = updatedQuestions.map((q, index) => ({
      ...q,
      id: index + 1,
    }))
    props.setQuestions(renumberedQuestions)
  }

  const handleAddFarewell = () => {
    const newFarewell = {
      id: 1,
      title: "Interview Completed Successfully üòä",
      description: "Thank you for completing the interview, we will get back to you shortly.",
      video: null,
    }
    props.setFarewell([newFarewell])
  }

  const handleRemoveFarewell = () => {
    props.setFarewell([])
  }

  // Settings management
  const handleSettingsClick = (questionId) => {
    setCurrentQuestionSettings(questionId)
    setShowSettingsPopup(true)
  }

  const handleSettingsChange = (setting, value) => {
    setQuestionSettings((prev) => ({
      ...prev,
      [currentQuestionSettings]: {
        ...prev[currentQuestionSettings],
        [setting]: value,
      },
    }))
  }

  const closeSettingsPopup = () => {
    if (currentQuestionSettings) {
      const updatedQuestions = props.questions.map((q) => {
        if (q.id === currentQuestionSettings) {
          const settings = questionSettings[currentQuestionSettings] || {}
          return {
            ...q,
            Timetothink: settings.Timetothink || q.Timetothink,
            Timetoanswer: settings.Timetoanswer || q.Timetoanswer,
            Retakes: settings.Retakes || q.Retakes,
          }
        }
        return q
      })
      props.setQuestions(updatedQuestions)
    }
    setShowSettingsPopup(false)
    setCurrentQuestionSettings(null)
  }

  // Preview functionality
  const createPreviewData = () => {
    const previewItems = []

    if (props.interviewStartVideo) {
      previewItems.push({
        type: "intro",
        title: props.interviewStartTitle || "Welcome to the Interview",
        description: "Please watch this introduction video before we begin.",
        video: props.interviewStartVideo,
      })
    }

    props.questions.forEach((question, index) => {
      if (question.video) {
        previewItems.push({
          type: "question",
          title: question.title || `Question ${index + 1}`,
          description: question.description || "No description provided.",
          video: question.video,
          number: index + 1,
        })
      }
    })

    if (props.farewell.length > 0 && props.farewell[0].video) {
      previewItems.push({
        type: "farewell",
        title: props.farewell[0].title || "Thank You!",
        description: props.farewell[0].description || "Thank you for completing the interview.",
        video: props.farewell[0].video,
      })
    }

    return previewItems
  }

  const openPreview = () => {
    const previewData = createPreviewData()
    if (previewData.length === 0) {
      Swal.fire({
        icon: "warning",
        title: "No Content to Preview",
        text: "Please add at least one video to preview the interview.",
      })
      return
    }
    setPreviewCount(0)
    setIsPopupOpen(true)
  }

  // Drag and drop for reordering questions
  const handleQuestionDragStart = (e, questionId) => {
    setDraggedItem(questionId)
    e.dataTransfer.effectAllowed = "move"
  }

  const handleQuestionDragOver = (e) => {
    e.preventDefault()
    e.dataTransfer.dropEffect = "move"
  }

  const handleQuestionDrop = (e, targetId) => {
    e.preventDefault()

    if (draggedItem && draggedItem !== targetId) {
      const draggedIndex = props.questions.findIndex((q) => q.id === draggedItem)
      const targetIndex = props.questions.findIndex((q) => q.id === targetId)

      const newQuestions = [...props.questions]
      const [draggedQuestion] = newQuestions.splice(draggedIndex, 1)
      newQuestions.splice(targetIndex, 0, draggedQuestion)

      const renumberedQuestions = newQuestions.map((q, index) => ({
        ...q,
        id: index + 1,
      }))

      props.setQuestions(renumberedQuestions)
    }
    setDraggedItem(null)
  }

  // Get video preview URL
  const getVideoPreviewUrl = (video) => {
    if (!video) return null
    if (typeof video === "string") return video
    if (video instanceof File || video instanceof Blob) {
      return URL.createObjectURL(video)
    }
    return null
  }

  return (
    <div className="main-container">
      <div className="content-wrapper">
        <div className="back-button-container">
          <button onClick={props.prevStep} className="back-button">
            ‚Üê Back
          </button>
        </div>

        <div className="interview-creation-container">
          {/* Interview Starter Section */}
          <div className="starter-section">
            <div
              className="video-upload-area"
              onDragOver={handleDragOver}
              onDragLeave={handleDragLeave}
              onDrop={(e) => handleDrop(e, (file) => props.setInterviewStartVideo(file))}
              onClick={() => handleIntroVideoUpload("record")}
            >
              {props.interviewStartVideo && (
                <div className="video-action-buttons">
                  <div
                    onClick={(e) => {
                      e.stopPropagation()
                      props.setInterviewStartVideo(null)
                    }}
                    className="delete-video-button"
                    title="Delete Video"
                  >
                    <FiTrash size={20} />
                  </div>
                </div>
              )}

              {props.interviewStartVideo ? (
                <video src={getVideoPreviewUrl(props.interviewStartVideo)} controls className="preview-video" />
              ) : (
                <div className="upload-content">
                  <FaVideo size={30} />
                  <h3>Interview Starter</h3>
                  <p>Click to record or drop video file here</p>
                  <div className="upload-buttons">
                    <button onClick={(e) => { e.stopPropagation(); handleIntroVideoUpload("record"); }}>Record Video</button>
                    <button onClick={(e) => { e.stopPropagation(); handleIntroVideoUpload("upload"); }}>Upload Video</button>
                  </div>
                </div>
              )}
            </div>

            <div className="title-section">
              <input
                type="text"
                placeholder="Enter your interview title here..."
                className="interview-title-input"
                value={props.interviewStartTitle}
                onChange={(e) => props.setInterviewStartTitle(e.target.value)}
              />
            </div>
          </div>

          {/* Questions Section */}
          {props.questions.map((question, index) => (
            <div
              key={question.id}
              className="question-section"
              draggable
              onDragStart={(e) => handleQuestionDragStart(e, question.id)}
              onDragOver={handleQuestionDragOver}
              onDrop={(e) => handleQuestionDrop(e, question.id)}
            >
              <div>
                <div className="number-circle">{index + 1}</div>
              </div>
              <div className="quesntioncomparter">
                <div
                  className="video-upload-area"
                  onDragOver={handleDragOver}
                  onDragLeave={handleDragLeave}
                  onDrop={(e) =>
                    handleDrop(e, (file) => {
                      const updatedQuestions = props.questions.map((q) =>
                        q.id === question.id ? { ...q, video: file } : q
                      )
                      props.setQuestions(updatedQuestions)
                    })
                  }
                  onClick={() => handleQuestionVideoUpload(question.id, "record")}
                >
                  {question.video && (
                    <div className="video-action-buttons">
                      <div
                        onClick={(e) => {
                          e.stopPropagation()
                          const updatedQuestions = props.questions.map((q) =>
                            q.id === question.id ? { ...q, video: null } : q
                          )
                          props.setQuestions(updatedQuestions)
                        }}
                        className="delete-video-button"
                        title="Delete Video"
                      >
                        <FiTrash size={20} />
                      </div>
                    </div>
                  )}

                  {question.video ? (
                    <video src={getVideoPreviewUrl(question.video)} controls className="preview-video" />
                  ) : (
                    <div className="upload-content">
                      <FaVideo className="video-icon" />
                      <h3>Question Video</h3>
                      <p>Click to record or drop video file here</p>
                      <div className="upload-buttons">
                        <button onClick={(e) => { e.stopPropagation(); handleQuestionVideoUpload(question.id, "record"); }}>Record Video</button>
                        <button onClick={(e) => { e.stopPropagation(); handleQuestionVideoUpload(question.id, "upload"); }}>Upload Video</button>
                      </div>
                    </div>
                  )}
                </div>

                <div className="question-content">
                  <div className="input-fields">
                    <div className="question-content-child1">
                      <input
                        type="text"
                        placeholder="Question title here"
                        value={question.title || ""}
                        onChange={(e) => {
                          const updatedQuestions = props.questions.map((q) =>
                            q.id === question.id ? { ...q, title: e.target.value } : q
                          )
                          props.setQuestions(updatedQuestions)
                        }}
                        className="question-input"
                      />
                      <textarea
                        placeholder="Full question (max 1200 chars)"
                        maxLength="1200"
                        value={question.description || ""}
                        onChange={(e) => {
                          const updatedQuestions = props.questions.map((q) =>
                            q.id === question.id ? { ...q, description: e.target.value } : q
                          )
                          props.setQuestions(updatedQuestions)
                        }}
                        className="question-textarea"
                      />
                    </div>
                    <div className="action-icons">
                      <div className="icon-button settings-icon" onClick={() => handleSettingsClick(question.id)}>
                        <FiSettings />
                      </div>
                      <div className="icon-button delete-icon" onClick={() => handleRemoveQuestion(question.id)}>
                        <FiTrash />
                      </div>
                      <div className="icon-button delete-icon" onDragStart={(e) => handleQuestionDragStart(e, question.id)}
                        onDragOver={handleQuestionDragOver}
                        onDrop={(e) => handleQuestionDrop(e, question.id)}>
                        <MdDragIndicator size={24} />
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          ))}

          {/* Add Question/Farewell Buttons */}
          <div className="button-container">
            <button className="add-button" onClick={handleAddQuestion}>
              + Add Question
            </button>

            {props.farewell.length === 0 && (
              <button className="add-button farewell-button" onClick={handleAddFarewell}>
                + Add Farewell Video & Message
              </button>
            )}
          </div>

          {/* Farewell Section */}
          {props.farewell.map((farewellItem) => (
            <div key={farewellItem.id} className="question-section farewell-section">
              <div className="number-circle farewell-circle">
                <GiPartyPopper />
              </div>
              <div className="quesntioncomparter">
                <div
                  className="video-upload-area"
                  onDragOver={handleDragOver}
                  onDragLeave={handleDragLeave}
                  onDrop={(e) =>
                    handleDrop(e, (file) => {
                      const updatedFarewell = props.farewell.map((f) =>
                        f.id === farewellItem.id ? { ...f, video: file } : f
                      )
                      props.setFarewell(updatedFarewell)
                    })
                  }
                  onClick={() => handleFarewellVideoUpload(farewellItem.id, "record")}
                >
                  {farewellItem.video && (
                    <div className="video-action-buttons">
                      <div
                        onClick={(e) => {
                          e.stopPropagation()
                          const updatedFarewell = props.farewell.map((f) =>
                            f.id === farewellItem.id ? { ...f, video: null } : f
                          )
                          props.setFarewell(updatedFarewell)
                        }}
                        className="delete-video-button"
                        title="Delete Video"
                      >
                        <FiTrash size={20} />
                      </div>
                    </div>
                  )}

                  {farewellItem.video ? (
                    <video src={getVideoPreviewUrl(farewellItem.video)} controls className="preview-video" />
                  ) : (
                    <div className="upload-content">
                      <FaVideo className="video-icon" />
                      <h3>Farewell Video</h3>
                      <p>Click to record or drop video file here</p>
                      <div className="upload-buttons">
                        <button onClick={(e) => { e.stopPropagation(); handleFarewellVideoUpload(farewellItem.id, "record"); }}>Record Video</button>
                        <button onClick={(e) => { e.stopPropagation(); handleFarewellVideoUpload(farewellItem.id, "upload"); }}>Upload Video</button>
                      </div>
                    </div>
                  )}
                </div>

                <div className="question-content">
                  <div className="input-fields">
                    <div className="question-content-child1">
                      <input
                        type="text"
                        placeholder="Farewell title (max 40 chars)"
                        maxLength="40"
                        value={farewellItem.title}
                        onChange={(e) => {
                          const updatedFarewell = props.farewell.map((f) =>
                            f.id === farewellItem.id ? { ...f, title: e.target.value } : f
                          )
                          props.setFarewell(updatedFarewell)
                        }}
                        className="question-input"
                      />
                      <textarea
                        placeholder="Farewell message (max 1200 chars)"
                        maxLength="1200"
                        value={farewellItem.description}
                        onChange={(e) => {
                          const updatedFarewell = props.farewell.map((f) =>
                            f.id === farewellItem.id ? { ...f, description: e.target.value } : f
                          )
                          props.setFarewell(updatedFarewell)
                        }}
                        className="question-textarea"
                      />
                    </div>
                    <div className="action-icons">
                      <div className="icon-button delete-icon" onClick={handleRemoveFarewell}>
                        <FiTrash />
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          ))}

          {/* Save Buttons */}
          <div className="save-button-container">
            <button onClick={openPreview} className="save-button" disabled={props.isUploading}>
              Preview Interview
            </button>
            <button onClick={props.saveInterview} className="save-button" disabled={props.isUploading}>
              {props.isUploading ? (
                <>
                  <FaSpinner className="spinner" /> Saving...
                </>
              ) : (
                "Save Interview"
              )}
            </button>
          </div>
        </div>

        {/* Preview Popup */}
        {isPopupOpen && (
          <div className="creatingsteppopup-vi-popup-overlay">
            <div className="creatingsteppopup-vi-popup-container">
              <div className="creatingsteppopup-vi-popup-close-button" onClick={() => setIsPopupOpen(false)}>
                <FiX size={24} />
              </div>

              <div className="creatingsteppopup-vi-popup-content">
                <div className="creatingsteppopup-vi-popup-video-section">
                  <div className="creatingsteppopup-vi-popup-video-wrapper">
                    <div className="creatingsteppopup-vi-popup-video-container">
                      <video
                        className="creatingsteppopup-vi-popup-video"
                        src={getVideoPreviewUrl(createPreviewData()[previewCount]?.video)}
                        controls
                        autoPlay
                      />
                    </div>

                    <div className="creatingsteppopup-vi-popup-progress">
                      <div className="creatingsteppopup-vi-popup-progress-text">
                        {previewCount + 1} / {createPreviewData().length}
                      </div>
                      <div className="creatingsteppopup-vi-popup-progress-bar">
                        <div
                          className="creatingsteppopup-vi-popup-progress-fill"
                          style={{
                            width: `${((previewCount + 1) / createPreviewData().length) * 100}%`,
                          }}
                        />
                      </div>
                    </div>
                  </div>

                  <div className="creatingsteppopup-vi-popup-info-section">
                    <div className="creatingsteppopup-vi-popup-info-content">
                      <div className="creatingsteppopup-vi-popup-badge">
                        {createPreviewData()[previewCount]?.type === "intro" && "Introduction"}
                        {createPreviewData()[previewCount]?.type === "question" &&
                          `Question ${createPreviewData()[previewCount]?.number}`}
                        {createPreviewData()[previewCount]?.type === "farewell" && "Farewell"}
                      </div>

                      <h1 className="creatingsteppopup-vi-popup-question-title">
                        {createPreviewData()[previewCount]?.title}
                      </h1>

                      <div className="creatingsteppopup-vi-popup-divider" />

                      <div className="creatingsteppopup-vi-popup-question-description">
                        {createPreviewData()[previewCount]?.description}
                      </div>

                      <div className="creatingsteppopup-vi-popup-actions">
                        {previewCount > 0 && (
                          <button
                            className="creatingsteppopup-vi-popup-prev-button"
                            onClick={() => setPreviewCount(previewCount - 1)}
                          >
                            ‚Üê Previous
                          </button>
                        )}

                        {previewCount < createPreviewData().length - 1 ? (
                          <button
                            className="creatingsteppopup-vi-popup-next-button"
                            onClick={() => setPreviewCount(previewCount + 1)}
                          >
                            Next ‚Üí
                          </button>
                        ) : (
                          <button
                            className="creatingsteppopup-vi-popup-next-button"
                            onClick={() => setIsPopupOpen(false)}
                          >
                            Finish Preview
                          </button>
                        )}
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Settings Popup */}
        {showSettingsPopup && (
          <div className="settings-popup-overlay">
            <div className="settings-popup">
              <div className="popup-header">
                <h3>Question Settings</h3>
                <div onClick={closeSettingsPopup} className="close-button">
                  <FiX />
                </div>
              </div>

              <div className="popup-content">
                <div className="setting-group">
                  <label>Time to think</label>
                  <select
                    value={questionSettings[currentQuestionSettings]?.Timetothink || ""}
                    onChange={(e) => handleSettingsChange("Timetothink", e.target.value)}
                    className="setting-select"
                  >
                    <option value="">Select Time to think</option>
                    {settingsOptions.Timetothink.map((option) => (
                      <option key={option.value} value={option.value}>
                        {option.label}
                      </option>
                    ))}
                  </select>
                </div>

                <div className="setting-group">
                  <label>Time to answer</label>
                  <select
                    value={questionSettings[currentQuestionSettings]?.Timetoanswer || ""}
                    onChange={(e) => handleSettingsChange("Timetoanswer", e.target.value)}
                    className="setting-select"
                  >
                    <option value="">Select Time to answer</option>
                    {settingsOptions.Timetoanswer.map((option) => (
                      <option key={option.value} value={option.value}>
                        {option.label}
                      </option>
                    ))}
                  </select>
                </div>

                <div className="setting-group">
                  <label>Retakes</label>
                  <select
                    value={questionSettings[currentQuestionSettings]?.Retakes || ""}
                    onChange={(e) => handleSettingsChange("Retakes", e.target.value)}
                    className="setting-select"
                  >
                    <option value="">Select Retakes</option>
                    {settingsOptions.Retakes.map((option) => (
                      <option key={option.value} value={option.value}>
                        {option.label}
                      </option>
                    ))}
                  </select>
                </div>
              </div>

              <div className="popup-footer">
                <button onClick={closeSettingsPopup} className="apply-button">
                  Apply Settings
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}

export default Step2
